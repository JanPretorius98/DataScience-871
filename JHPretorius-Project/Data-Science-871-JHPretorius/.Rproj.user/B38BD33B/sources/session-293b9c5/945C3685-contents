---
title: "Data-Science-871-JHPretorius-Project"
author: "JH Pretorius"
date: "2023-05-24"
output: html_document
css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preface

```{r housekeeping, message=FALSE, warning=FALSE, results=FALSE}
# goal: "Threefold: (1) Transformation and cleaning of data. (2) Exploratory Data Analysis of Dating Site Data. (3) Machine Learning modelling."

# Clear environment
rm(list = ls())
options(scipen = 999)

# Load packages in use
pacman::p_load(dplyr, ggplot2, tidyverse, rsample, caret, glmnet, vip, pdp, stringr, 
               tidytext, emoji, stopwords, ggridges, wordcloud2, ggmap, readxl, maps,
               viridis, eurostat, rayshader)

# Define plot themes and palettes
palette <- c("#1beaa7", "#00d9d3", "#C93A86", "#00a5ff", "#007bff", "#8c2aef")

th <- theme(legend.position = "bottom",
            panel.background = element_blank(),
            plot.background = element_rect(fill = "#000123", color = "#000123"),
            panel.grid.major = element_line(color="white", size = 0.1),
            panel.grid.minor = element_line(color="white", size = 0.1),
            axis.title.x=element_text(colour="white", size = 12,
                                      family = "arial", vjust=-2,hjust=0.5, face = "bold"),
            axis.title.y=element_text(colour="white", size = 12,
                                      family = "arial",vjust = 3,hjust=0.5, face = "bold"),
            axis.text.y=element_text(colour ="white", size = 10, 
                                     family = "arial"),
            axis.text.x=element_text(colour="white", size = 10,
                                     family = "arial"),
            plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
            plot.title = element_text(colour="white", size = 16,
                                      family = "arial",hjust=0.5, face = "bold"),
            plot.subtitle = element_text(colour="white", size = 14,
                                         family = "arial"),
            plot.caption = element_text(colour="white", size = 10,
                                        family = "arial"),
            legend.text = element_text(colour="white", size = 12,
                                       family = "arial"),
            legend.title = element_text(colour="white", size = 12,
                                        family = "arial", hjust=3, face = "bold"),
            axis.ticks = element_blank(),
            strip.text = element_text(colour="white", size = 12,
                                      family = "arial", vjust=1,hjust=0.5),
            legend.key = element_rect(fill = "#000123", color = "#000123"),
            legend.background = element_rect(fill = "#000123"))

# Import data
path <- "/Users/janhendrikpretorius/Library/CloudStorage/OneDrive-StellenboschUniversity/Masters-2023/Modules/Data Science/DataScience-871-repo/JHPretorius-Project/Candidate Data Sets/Dating/"
file <- "lovoo_v3_users_api-results.csv"

df <- read_csv(paste0(path, file))

```

# Introduction

In this project, my aim is to uncover the defining characteristics that contribute to an individual's attractiveness, popularity, and fame. My strategy involves using data from Lovoo, a European dating site/app, which is available through [Kaggle](https://www.kaggle.com/datasets/utkarshx27/lovoo-dating-app-dataset?select=lovoo_v3_users_api-results.csv). Driven by a keen interest to understand behavioural traits beyond mere physical attractiveness, I am determined to reveal hidden attributes that potentially shape interpersonal interactions within the sphere of a dating app environment. Dating site behaviour carries relevance even in economic circles, as an understanding of this paradigm may be used to bolster economic models to study relationship initiation as an analytic framework to explain overall mate-selection behavior.

The analysis commences with the transformation of raw data into a more insightful format, by creating additional variables designed to enhance the predictive power of subsequent statistical models. This process allows me to delve into an exploratory role, as I sift through the data in search of characteristics that could indicate valuable predictive variables. The goal is not just to understand but to forecast which factors lead to an increased number of profile views and 'likes' received.

To this end, I construct a random forest model, a powerful tool in discerning the intricate characteristics that influence human behaviour. The model functions as a compass, guiding me towards a deeper understanding of the underpinnings of attraction, popularity, and fame in the digital dating landscape.

# Part 1: Transformation and Cleaning

The data contain around 40 different variables, containing information on a particular profile and other demographics. An extract of the data is included below, along with Table 1 that describes some of the relevant variables. The data set only contains data on individuals that identify as female. To this end, I am essentially attempting to understand which factors determine the behaviour of individuals interested in females.

#### Head of dataframe

```{r echo=FALSE}
head(df)
```

#### Table 1: Description of variables in data set.

| Variable               | Description                                                                                                                                 |
|--------------------|----------------------------------------------------|
| `genderLooking`        | Preferred gender the subject is looking to engage with. Represented as 'M' for male, 'F' for female, 'both' for male and female, or 'none'. |
| `age`                  | Age of the individual.                                                                                                                      |
| `counts_details`       | How complete the profile is. Proportion of detail in the account. Measured from 0.0-1.0.                                                    |
| `counts_pictures`      | How many pictures does the profile contain.                                                                                                 |
| `counts_profileVisits` | How many times the profile has been viewed.                                                                                                 |
| `counts_kisses`        | Number of 'kisses' or 'likes' received by profile.                                                                                          |
| `flirtInterests_*`     | What the individual is interested in. '*' represents: 'chat', 'date', 'friends'.                                                             |
| `verified`             | Whether the profile has been verified or not.                                                                                               |
| `lang_count`           | Number of languages spoken by an individual.                                                                                                |
| `lang_*`               | Language spoken by an individual. '*' represents: 'en' (English), 'de' (German), 'fr' (French), 'it' (Italian), 'es' (Spanish).              |
| `whazzup`              | A phrase that represents the profile's 'bio'.                                                                                               |

The raw data is already very useable, but some new variables must be added to produce better models. The first data transformation is to consider the language used by individuals in their profiles. To this end, there are two main operations when discerning the effect of language use on individual behaviour: words used in biographies, and emoji use. Both these factors may reveal characteristics underlying confidence and perceived desirability.

The code chunk below creates two new dummy variables, `has_emoji` and `contains_popular_word`. `has_emoji` attributes a '1' based on whether `wazzup` contains an emoji. `contains_popular_word` attributes a '1' based on whether `wazzup` contains a popular word. The code chunk also outputs which words are the most popular in a word cloud. (The word cloud is a dynamic image that shows the popularity when hovering over a specific word)

```{r words}

# Define dummy variable that detects presence of emojis
df <- df %>%
  mutate(has_emoji = ifelse(emoji_detect(whazzup), 1, 0))

# Get the most used words in profile
# First, create a table of words with the corresponding counts_profileVisits
words_visits <- df %>%
  unnest_tokens(word, whazzup) %>%
  mutate(word = str_remove_all(word, "[[:digit:]]+")) %>%
  select(word, counts_profileVisits)

# Then calculate the mean counts_profileVisits for each word and its count
words <- words_visits %>%
  group_by(word) %>%
  summarise(mean_profileVisits = mean(counts_profileVisits, na.rm = TRUE),
            word_count = n(), 
            .groups = "drop")

# Create word popularity index and determine popular words
  # Important to remove stop words from list of popular words, as they are frequently used, but carry no significant meaning
words <- words %>%
  mutate(popularity_index = 0.8 * word_count + 0.2 * mean_profileVisits) %>% 
  filter(popularity_index > 200 & word_count > 10, 
         word != "", 
         !is.na(word), 
         !is.na(mean_profileVisits), 
         !is.na(word_count), 
         !is.na(popularity_index)) %>%
  filter(!word %in% stopwords::stopwords("de")) %>%
  filter(!word %in% stopwords::stopwords("en")) %>% 
  filter(!word %in% stopwords::stopwords("fr"))

# Create a single pattern string that matches any word in words$word
words_pattern <- paste(words$word, collapse = "|")

# Add the new variable to df
df <- df %>%
  mutate(contains_popular_word = ifelse(str_detect(whazzup, words_pattern), 1, 0)) %>%
  mutate(
    contains_popular_word = replace_na(contains_popular_word, 0),
    has_emoji = replace_na(has_emoji, 0)
  )

words <- words %>%
  arrange(desc(popularity_index)) %>% 
  select(c(word, popularity_index))
```
####    Figure 1: Word cloud of popular words in bios.
```{r echo=FALSE, fig.align="center"}
# Create Word Cloud
wordcloud2(words, size=1.6, color='random-light', backgroundColor = "#000123")
```

Interestingly, one may see that popular words (those are words that get many profile views and are used frequently), are social media tags. That is, individuals that have their social media details, such as their Instagram handle, Facebook name, and Snapchat handle, tend to get more profile views. As such, I will create another variable, called `has_social` that captures whether a profile contains social media particulars. Due to endogeneity and possible multicollinearity between `contains_popular_word` and `has_social`, only one can be used in modelling. Whichever delivers the most accurate result will then be used.

```{r warning=FALSE}

social <- "instagram|insta|facebook|fb|snapchat|snap"
df <- df %>%
  mutate(whazzup = tolower(whazzup),
         has_social = as.numeric(str_detect(whazzup, social))) %>%
  replace_na(list(has_social = 0))

```


A final operation pertains to the time an individual is online. I add a new dummy variable called `night_owl` to the dataframe based on whether a person was online at night or not. The motivation behind this is that dating apps tend to be more popular in the evenings, than during daytime.

```{r, warning=FALSE}
df <- df %>%
  mutate(night_owl = ifelse(hour(hms(substr(lastOnlineDate, 12, 19))) > 18 | 
                            hour(hms(substr(lastOnlineDate, 12, 19))) < 6, 1, 0))

```

# Part 2: Exploratory Data Analysis

This section concerns finding relationships in the data. I initiate with a graphical analysis of the different variables to determine their relevance. Thereafter, I made use of a stepwise regression to determine which variables produce the best fitting model. However, it is important to not disregard some variables because they did not pass the 'stepwise' test. As such the final model will be advised by the results of the stepwise regression, but not absolutely decided by it.

##    Biography characteristics and popularity

Figures 2 and 3 below seek to understand whether there is a difference in mean profile views based on the newly created dummy variables, `has_emoji`, `contains_popular_word`, and `night_owl`. There seem to be some slight differences in mean profile views, supporting the idea that the use of emojis and certain words do suggest higher levels of trust. Being online during night time also may increase profile views, but I view this variable more as a control variable, rather than a causal one, as more people tend to be online during night time than in day time.

#### Figure 2: Boxplots showing effects of a bio containing social media particulars, a popular word, an emoji, and/or being a night owl on profile views.

```{r, echo=FALSE, fig.align="center", fig.height= 10, fig.width=8}

df %>%
  filter(counts_profileVisits < 10000, !is.na(night_owl), !is.na(has_social)) %>%
  mutate(has_emoji = factor(has_emoji, labels = c("No", "Yes")),
         contains_popular_word = factor(contains_popular_word, labels = c("No", "Yes")),
         night_owl = factor(night_owl, labels = c("No", "Yes")),
         has_social = factor(has_social, labels = c("No", "Yes"))) %>%
  pivot_longer(cols = c(has_emoji, contains_popular_word, night_owl, has_social), names_to = "Factor", values_to = "Value") %>%
  mutate(Factor = recode(Factor, 
                         has_emoji = "Emoji", 
                         contains_popular_word = "Popular Words",
                         night_owl = "Night Owl",
                         has_social = "Social Media")) %>%
  ggplot(aes(x = Value, y = counts_profileVisits, fill = Value)) +
  geom_boxplot(colour = "white", alpha = 0.8) +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef")) +
  facet_wrap(~ Factor, scales = "free", strip.position = "top") +
  labs(x = "", y = "Profile Visits Count", fill = "") +
  th +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 14),
    axis.text.x = element_blank()
  )


```

The density plots in figure 2 suggest that those profiles with bios not containing popular words or emojis have a lower mean profile views, whereas those that do have a tendency to have higher profile views. The same observation is present with the night owls, versus the early birds.

#### Figure 3: Density plots showing effects of a bio containing social media particulars, a popular word, an emoji, and/or being a night owl on profile views.

```{r, echo=FALSE, fig.align="center", fig.height= 10, fig.width=8}

df %>%
  filter(counts_profileVisits < 10000, !is.na(night_owl), !is.na(has_social)) %>%
  gather("group", "value", has_emoji, contains_popular_word, night_owl, has_social) %>%
  ggplot(aes(x = counts_profileVisits, fill = factor(value))) +
  geom_density(alpha = 0.8, colour = "white") +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef"), 
                    name = "", 
                    labels = c("No", "Yes")) +
  facet_wrap(~ group, labeller = as_labeller(c(has_emoji = "Emoji",
                                               contains_popular_word = "Popular Words",
                                               night_owl = "Night Owl",
                                               has_social = "Social Media"))) +
  labs(x = "Profile Visits Count", y = "Density", fill = "Category") +
  th +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 14)
  )

```
##    Geographical characteristics and popularity

By using my Google Maps API, I was able to geocode the locations of every profile in the data. The goal is to visualise how location effects profile views. The code chunk below was used to geocode the data (but is commented out, because there are costs associated with geocoding through the API).
```{r}
# df_city <- df %>% 
#   select(c(city, country, counts_profileVisits)) %>% 
#   mutate(address = paste0(city, ", ", country)) %>%
#   group_by(address) %>%
#   summarise(mean_profile_views = mean(counts_profileVisits, na.rm = TRUE))
# 
# df_city <- df_city %>%
#   mutate(geocode_data = map(address, ~geocode(.x, source = "google", output = "latlon")),
#          lon = map_dbl(geocode_data, "lon"),
#          lat = map_dbl(geocode_data, "lat"))
# 
# write_csv(df_city, "geocode_latlon.csv")

```

```{r}
df_city <- read_excel("geocode_latlon.xlsx")

df_city <- df_city %>%
  mutate(mean_profile_views = as.numeric(mean_profile_views),
         lat = as.numeric(lat),
         lon = as.numeric(lon)) %>% 
  filter(!is.na(lon),
         mean_profile_views > 0,
         lon > -90 & lon < 100,
         lat > 0)

# Filter by countries after data cleaning and transformation
df_city <- df_city %>%
  filter(substr(address, nchar(address) - 1, nchar(address)) %in% eu_countries$code | address == "UK")

world <- map_data("world") %>%
  filter(region %in% eu_countries$name | region == "UK")

map <-  ggplot() +
    geom_polygon(data = world, aes(x=long, y = lat, group = group), fill="white", alpha=0.3) +
    geom_point(data = df_city, aes(x=lon, y=lat, color=mean_profile_views), alpha=0.9) +
    scale_size_continuous(range=c(1,12)) +
    scale_color_viridis(trans="log") + th + coord_map() + theme(legend.position="none")

library(rayshader)
```


#### Figure 4: Bubble plot of number of kisses received and profile views. A non-linear model (loess method) was once again fitted on the plot to discern possible patterns and differences between bios with emojis and those without. Size of dots present how detailed the account is.

```{r echo=FALSE, fig.align="center", message=FALSE}

df %>%
  filter(counts_profileVisits < 100000) %>% 
  ggplot(aes(y = counts_profileVisits, x = counts_pictures)) +
  geom_point(aes(fill = factor(has_emoji), size = counts_details), pch = 21, alpha = 0.8, colour = "white") +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji")) +
  scale_size(range = c(0.2, 3)) +
  labs(y = "Profile Visits Count", x = "Pictures Count", size = "Details Count", fill = "Contains Emoji") +
  th + theme(legend.position = "right") +
  geom_smooth(aes(colour = factor(has_emoji)), method = "loess", se = FALSE) +
  scale_colour_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji"))


```

#### Figure 5: Bubble plot of profile views and number of pictures in profile. A non-linear model (loess method) was fitted on the plot to discern possible patterns and differences between bios with emojis and those without. Size of dots present how detailed the account is.

```{r echo=FALSE, fig.align="center", message=FALSE}
df %>%
  filter(counts_profileVisits < 100000 & counts_kisses < 6000) %>% 
  ggplot(aes(x = counts_profileVisits, y = counts_kisses)) +
  geom_point(aes(fill = factor(has_emoji), size = counts_details), pch = 21, alpha = 0.8, colour = "white") +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji")) +
  scale_size(range = c(0.1, 4)) +
  labs(x = "Profile Visits Count", y = "Number of Kisses", size = "Details Count", fill = "Contains Emoji") +
  th + theme(legend.position = "right") +
  geom_smooth(aes(colour = factor(has_emoji)), method = "loess", se = FALSE) +
  scale_colour_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji"))


```

# Part 3: Modelling & Results

# Discussion & Conclusion
