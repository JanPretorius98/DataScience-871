---
title: "Data Science 871 Project"
output: html_document
css: styles.css
---

```{r echo = FALSE, fig.align='center'}
knitr::include_graphics("jan_logo.png")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preface

### Project Goal: Threefold: (1) Transformation and cleaning of data. (2) Exploratory Data Analysis of Dating Site Data. (3) Machine Learning modelling.

### Create Themes and Load Data:

```{r housekeeping, message=FALSE, warning=FALSE, results=FALSE}
# Clear environment
rm(list = ls())
options(scipen = 999)

# Load packages in use
pacman::p_load(dplyr, ggplot2, tidyverse, rsample, caret, glmnet, vip, pdp, stringr, 
               tidytext, emoji, stopwords, ggridges, wordcloud2, ggmap, readxl, maps,
               viridis, eurostat, corrplot, GGally, reshape2, grid, rpart, rpart.plot, 
               randomForest)

# Define plot themes and palettes
palette <- c("#1beaa7", "#00d9d3", "#00c2ff", "#00a5ff", "#007bff", "#8c2aef")

th <- theme(
  # Background and grid
  panel.background = element_blank(),
  plot.background = element_rect(fill = "#000123", color = "#000123"),
  panel.grid.major = element_line(color = "white", size = 0.1),
  panel.grid.minor = element_line(color = "white", size = 0.1),
  
  # Axis titles and labels
  axis.title.x = element_text(colour = "white",size = 12,family = "arial",vjust = -2,hjust = 0.5,face = "bold"),
  axis.title.y = element_text(colour = "white",size = 12,family = "arial",vjust = 3,hjust = 0.5,face = "bold"),
  axis.text.y = element_text(colour = "white",size = 10,family = "arial"),
  axis.text.x = element_text(colour = "white",size = 10,family = "arial"),
  
  # Margins and spacing
  plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
  
  # Title, subtitle, and caption
  plot.title = element_text(colour = "white",size = 16,family = "arial",hjust = 0.5,face = "bold"),
  plot.subtitle = element_text(colour = "white",size = 14,family = "arial"),
  plot.caption = element_text(colour = "white",size = 10,family = "arial"),
  
  # Legend
  legend.position = "right",
  legend.text = element_text(colour = "white",size = 12,family = "arial"),
  legend.title = element_text(colour = "white",size = 12,family = "arial",hjust = 3,face = "bold"),
  legend.key = element_rect(fill = "#000123", color = "#000123"),
  legend.background = element_rect(fill = "#000123"),
  
  # Other
  axis.ticks = element_blank(),
  strip.text = element_text(colour = "white",size = 12,family = "arial",vjust = 1,hjust = 0.5)
)


# Import data
path <- "/Users/janhendrikpretorius/Library/CloudStorage/OneDrive-StellenboschUniversity/Masters-2023/Modules/Data Science/DataScience-871-repo/JHPretorius-Project/Candidate Data Sets/Dating/"
file <- "lovoo_v3_users_api-results.csv"

df <- read_csv(paste0(path, file))

```

# Introduction

```{r echo = FALSE, fig.align='center'}
knitr::include_graphics("lovoo_logo.png")
```

The objective of this study is to investigate the critical factors that contribute to an individual's appeal, popularity, and recognition within an online dating platform. The data utilised for this research is sourced from Lovoo, a prominent European dating application, and is accessible via [Kaggle](https://www.kaggle.com/datasets/utkarshx27/lovoo-dating-app-dataset?select=lovoo_v3_users_api-results.csv).

The underlying motivation for this study stems from the desire to comprehend behavioural patterns that transcend the confines of physical attractiveness. The aim is to unveil hidden determinants that may shape interpersonal interactions within a digital dating platform. The behaviour exhibited on these platforms carries significance, even in economic contexts. By deciphering this behavioural paradigm, it can potentially contribute to the development of economic models. These enhanced models can subsequently offer a more profound analytic framework to elucidate overall mate-selection behaviour.

The initial phase of the analysis involves the transformation of raw data into a more interpretable format. This includes the creation of additional variables tailored to augment the predictive capacity of the statistical models employed in subsequent stages. This phase facilitates the exploratory aspect of the research, enabling an in-depth examination of data in search of potential predictor variables. The objective extends beyond understanding the phenomena; the aim is to anticipate which factors instigate an increased number of profile views and, subsequently, the 'likes' received.

The modelling process is a two-step approach. The first stage focuses on identifying variables that may elucidate why individuals view a certain profile. Potential variables include online presence, age, geographical location, and the timing of an individual's online activity. The second stage aims to identify factors that influence the likelihood of a profile receiving 'likes'. These may include the number of pictures on a profile, the characteristics of a profile's biography, languages spoken, profile verification status, and mobile usage.

A decision tree model and random forest model are employed in this study, simply due to their robust ability to discern intricate characteristics that influence outcomes. The application of decision trees and random forests provides a comprehensive analysis approach, as it combines the simplicity and interpretability of decision trees, with the robustness and increased accuracy of random forests, to predict the distinct measures of user engagement on the dating platform. By training two models for each method, I ensure a more detailed understanding of the factors driving both profile views and likes.

# Part 1: Transformation and Cleaning

The dataset in consideration comprises 3 973 observations approximately 30 variables, each encapsulating specific attributes pertaining to individual profiles and related demographic information. An excerpt of the dataset is provided subsequently, supplemented by Table 1 which elucidates a selection of significant variables. It's noteworthy to mention that the dataset solely encompasses data of individuals identifying as female. As such, the core objective of this analysis is to discern the determinants influencing the behavioural patterns of individuals displaying interest in females.

#### Head of dataframe

```{r echo=FALSE}
head(df)
```

#### Table 1: Description of variables in data set.

| Variable               | Description                                                                                                                                 |
|-----------------------|-------------------------------------------------|
| `genderLooking`        | Preferred gender the subject is looking to engage with. Represented as 'M' for male, 'F' for female, 'both' for male and female, or 'none'. |
| `age`                  | Age of the individual.                                                                                                                      |
| `counts_details`       | How complete the profile is. Proportion of detail in the account. Measured from 0.0-1.0.                                                    |
| `counts_pictures`      | How many pictures does the profile contain.                                                                                                 |
| `counts_profileVisits` | How many times the profile has been viewed.                                                                                                 |
| `counts_kisses`        | Number of 'kisses' or 'likes' received by profile.                                                                                          |
| `flirtInterests_*`     | What the individual is interested in. '\*' represents: 'chat', 'date', 'friends'.                                                           |
| `verified`             | Whether the profile has been verified or not.                                                                                               |
| `lang_count`           | Number of languages spoken by an individual.                                                                                                |
| `lang_*`               | Language spoken by an individual. '\*' represents: 'en' (English), 'de' (German), 'fr' (French), 'it' (Italian), 'es' (Spanish).            |
| `whazzup`              | A phrase that represents the profile's 'bio'.                                                                                               |

The original dataset is already quite useable, but we can produce better models by adding some new variables. The first step is to take a closer look at the language people use in their profiles. I am focusing on two main things here: the words used in the profile descriptions, and the use of emojis. Both of these could give insights into the person's confidence and desirability.

The code chunk below creates two new dummy variables, `has_emoji` and `contains_popular_word`. `has_emoji` attributes a '1' based on whether `wazzup` contains an emoji. `contains_popular_word` attributes a '1' based on whether `wazzup` contains a popular word. The code chunk also outputs which words are the most popular in a word cloud. (The word cloud is a dynamic image that shows the popularity when hovering over a specific word)

```{r words}

# Define stop words for different languages
all_stop_words <- c(stopwords::stopwords("de"), stopwords::stopwords("en"), stopwords::stopwords("fr"))

# Define dummy variable that detects presence of emojis
# Also remove digits from 'whazzup' column
df <- df %>%
  mutate(has_emoji = ifelse(emoji_detect(whazzup), 1, 0),
         whazzup = str_remove_all(whazzup, "[[:digit:]]+"))

# Get the most used words in profile
# First, create a table of words with the corresponding counts_profileVisits
words_visits <- df %>%
  unnest_tokens(word, whazzup) %>%
  select(word, counts_profileVisits)

# Then calculate the mean counts_profileVisits for each word and its count
words <- words_visits %>%
  group_by(word) %>%
  summarise(mean_profileVisits = mean(counts_profileVisits, na.rm = TRUE),
            word_count = n(), 
            .groups = "drop")

# Create word popularity index and determine popular words
words <- words %>%
  mutate(popularity_index = 0.8 * word_count + 0.2 * mean_profileVisits) %>% 
  filter(popularity_index > 200 & word_count > 10, 
         word != "", 
         !is.na(word), 
         !is.na(mean_profileVisits), 
         !is.na(word_count), 
         !is.na(popularity_index)) %>%
  filter(!word %in% all_stop_words)

# Create a single pattern string that matches any word in words$word
words_pattern <- paste(words$word, collapse = "|")

# Add the new variable to df
df <- df %>%
  mutate(contains_popular_word = ifelse(str_detect(whazzup, words_pattern), 1, 0)) %>%
  mutate(
    contains_popular_word = replace_na(contains_popular_word, 0),
    has_emoji = replace_na(has_emoji, 0)
  )

words <- words %>%
  arrange(desc(popularity_index)) %>% 
  select(c(word, popularity_index))

```

#### Figure 1: Word cloud of popular words in bios.

```{r fig1, echo=FALSE, fig.align="center"}
# Create Word Cloud
wordcloud2(words, size=1.6, color='random-light', backgroundColor = "#000123")
```

Interestingly, one may see that popular words (those are words that get many profile views and are used frequently), are social media tags. That is, individuals that have their social media details, such as their Instagram handle, Facebook name, and Snapchat handle, on their account tend to get more profile views. As such, I will create another variable, called `has_social` that captures whether a profile contains social media particulars. Due to endogeneity and possible multicollinearity between `contains_popular_word` and `has_social`, only one can be used in modelling. Whichever delivers the most accurate result will then be used.

```{r social, warning=FALSE}

social <- "instagram|insta|facebook|fb|snapchat|snap"
df <- df %>%
  mutate(whazzup = tolower(whazzup),
         has_social = as.numeric(str_detect(whazzup, social))) %>%
  replace_na(list(has_social = 0))

```

Another operation pertains to the time an individual is online. I add a new dummy variable called `night_owl` to the dataframe based on whether a person was online at night or not. The motivation behind this is that dating apps tend to be more popular in the evenings, than during daytime.

```{r night_owl, warning=FALSE}
df <- df %>%
  mutate(night_owl = ifelse(hour(hms(substr(lastOnlineDate, 12, 19))) > 18 | 
                            hour(hms(substr(lastOnlineDate, 12, 19))) < 6, 1, 0))

```

Then, I transformed continuous numerical data from 'Profile Views' and 'Likes' into categorical variables, specifically 'Low', 'Low Mid', 'High Mid', and 'High'. This process, known as discretization, was achieved through quartile-based categorization, an effective method for handling large-range continuous data in predictive models.

Quartiles divide sorted data into quarters, aiding in capturing non-linear effects and minimizing outlier impact. For my data, 'Low' signifies values below the first quartile (25th percentile), 'Low Mid' denotes values between the first quartile and the median, 'High Mid' represents values between the median and the third quartile (75th percentile), and 'High' encompasses values above the third quartile. Despite the potential for information loss due to a reduction in distinct values, this method simplifies model interpretation and robustly handles outlier influence, key factors for ensuring reliable results.

```{r profile_cat}

# Categorize counts_profileVisits and counts_kisses based on quartiles
df$Profile_Views <- cut(df$counts_profileVisits, 
                                     breaks = quantile(df$counts_profileVisits, probs = 0:4/4, na.rm = TRUE), 
                                     labels = c("Low", "Low Mid", "High Mid", "High"), include.lowest = TRUE)

df$Profile_Likes <- cut(df$counts_kisses, 
                              breaks = quantile(df$counts_kisses, probs = 0:4/4, na.rm = TRUE), 
                              labels = c("Low", "Low Mid", "High Mid", "High"), include.lowest = TRUE)


```

Finally, before kicking off with the exploratory data analysis, it might be fitting to standardise the following three variables: `counts_profileVisits`, `counts_kisses`, and `counts_pictures`. This operation may help to more clearly visualise how some variables influence each other.

```{r standardise}

df$counts_profileVisitsStd <- scale(df$counts_profileVisits)
df$counts_kissesStd <- scale(df$counts_kisses)
df$counts_picturesStd <- scale(df$counts_pictures)

```

# Part 2: Exploratory Data Analysis

This segment aims to identify underlying patterns and relationships within the dataset. An initial step involves visually inspecting the variables, helping to assess their potential relevance and impact on the outcomes of interest. As a fundamental part of exploratory data analysis, these visual inspections allows one to discern which features could be instrumental in shaping predictive models.

As hinted in the introductory section, it quickly becomes apparent that specific variables have a more pronounced influence on the number of profile 'Likes', while others may largely dictate the number of 'Profile Views'. This distinction is crucial, as certain profile elements only become observable once a profile is viewed. For instance, the information in a profile biography only comes into play during a profile view. Therefore, the dynamics of what draws views and subsequently encourages likes may differ significantly, although both are important aspects of profile engagement.

Interestingly, despite these differences, one notices a robust correlation between profile views and likes. This interplay implies that a successful profile is not just about attracting views but also about converting those views into likes. Figure 2 visually represents this relationship, further illuminating the interdependent nature of profile views and likes. Uncovering these patterns provides essential insights that can inform our subsequent modeling efforts.

#### Figure 2: Bubble plot of profile views and number of pictures in profile. A non-linear model (loess method) was fitted on the plot to discern possible patterns and differences between bios with emojis and those without. Size of dots present how detailed the account is.

```{r fig2, echo=FALSE, fig.align="center", message=FALSE}
df %>%
  filter(counts_profileVisits < 100000) %>% 
  ggplot(aes(x = counts_profileVisits, y = counts_kisses)) +
  geom_point(aes(fill = factor(has_emoji), size = counts_details), pch = 21, alpha = 0.8, colour = "white") +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji")) +
  scale_size(range = c(0.1, 4)) +
  labs(x = "Profile Visits Count", y = "Number of Kisses", size = "Details Count", fill = "Contains Emoji") +
  th +
  geom_smooth(aes(colour = factor(has_emoji)), method = "loess", se = FALSE) +
  scale_colour_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji"))

```

## Biography characteristics and popularity

Figure 3 below aims to present whether there is a difference in the distribution of likes received based on the newly created dummy variables, `has_emoji`, `contains_popular_word`, and `night_owl`. There seem to be some slight differences in likes received, supporting the idea that the use of emojis and certain words do suggest higher levels of trust. Being online during night time also may increase profile views, but I view this variable more as a control variable, rather than a causal one, as more people tend to be online during night time than in day time.

#### Figure 3: Boxplots showing effects of profile characteristics on popularity. Left panel: effect of a bio containing social media particulars and/or an emoji on likes received. Right panel: effect of an online profile and/or being a night owl on number of profile visits.

```{r fig3, echo=FALSE, fig.align="center", fig.height= 10, fig.width=7, warning=FALSE}
plot1 <- df %>%
  filter(counts_kissesStd < 2, !is.na(night_owl), !is.na(has_social)) %>%
  mutate(has_emoji = factor(has_emoji, labels = c("No", "Yes")),
         night_owl = factor(night_owl, labels = c("No", "Yes")),
         has_social = factor(has_social, labels = c("No", "Yes"))) %>%
  pivot_longer(cols = c(has_emoji, has_social), names_to = "Factor", values_to = "Value") %>%
  mutate(Factor = recode(Factor, 
                         has_emoji = "Emoji",
                         has_social = "Social Media")) %>%
  ggplot(aes(x = Value, y = counts_kissesStd, fill = Value)) +
  geom_boxplot(colour = "white", alpha = 0.8) +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef")) +
  facet_wrap(~ Factor, scales = "free", strip.position = "top") +
  labs(x = "", y = "Profile Kisses Count (Standardised)", fill = "") +
  th +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 14),
    axis.text.x = element_blank(),
    legend.position = "none"
  ) +
  scale_y_continuous(breaks = c(-1, 0, 1, 2))

plot2 <- df %>%
  filter(counts_profileVisitsStd < 2, !is.na(night_owl), !is.na(isOnline)) %>%
  mutate(night_owl = factor(night_owl, labels = c("No", "Yes")),
         isOnline = factor(isOnline, labels = c("No", "Yes"))) %>%
  pivot_longer(cols = c(night_owl, isOnline), names_to = "Factor", values_to = "Value") %>%
  mutate(Factor = recode(Factor,
                         night_owl = "Night Owl",
                         isOnline = "Online")) %>%
  ggplot(aes(x = Value, y = counts_profileVisitsStd, fill = Value)) +
  geom_boxplot(colour = "white", alpha = 0.8) +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef")) +
  facet_wrap(~ Factor, scales = "free", strip.position = "top") +
  labs(x = "", y = "Profile Visits Count (Standardised)", fill = "") +
  th +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 14),
    axis.text.x = element_blank()
  ) +
  scale_y_continuous(breaks = c(-1, 0, 1, 2))
```

<div class="row">

::: col-md-6
```{r echo=FALSE}
plot1
```
:::

::: col-md-6
```{r echo=FALSE}
plot2
```
:::

## Geographical characteristics and popularity

Utilising the Google Maps API, I successfully geocoded the locations of all profiles present in the dataset. The primary objective behind this was to explore and visualise the potential impact of geographical location on profile views. The role of location might be significant, considering how geographical and cultural aspects can influence user interactions and preferences on the platform. The code snippet below shows the process to perform the geocoding operation.

```{r}
# Note: commented out, due to costs associated with geocoding through the API
# df_city <- df %>% 
#   select(c(city, country, counts_profileVisits)) %>% 
#   mutate(address = paste0(city, ", ", country)) %>%
#   group_by(address) %>%
#   summarise(mean_profile_views = mean(counts_profileVisits, na.rm = TRUE))
# 
# df_city <- df_city %>%
#   mutate(geocode_data = map(address, ~geocode(.x, source = "google", output = "latlon")),
#          lon = map_dbl(geocode_data, "lon"),
#          lat = map_dbl(geocode_data, "lat"))
# 
# write_csv(df_city, "geocode_latlon.csv")

```

The subsequent bubble plot illustrates a few disparities among cities. However, these contrasts are not significant enough to confirm any clear geographical trends in profile views. Thus, it is not feasible to definitively say that some regions show more inclination towards profile views than others based on this representation.

To gain a more insightful understanding, a choropleth map is utilized. This geographical representation not only gives a visual interpretation of data but also enhances comprehension through color-coding. Upon implementing this, it becomes noticeably clear that certain countries indeed experience higher profile views on average.

In particular, profiles originating from Spain, Hungary, and the Netherlands tend to attract more attention compared to other European countries. The reasons behind these trends can be plenty - cultural nuances, user behaviors, or the presence of more active users in these regions. Future investigation might delve deeper into these aspects to provide more concrete explanations for the observed patterns.

#### Figure 4: Geographic data visualisation of profile views. Size and colour of bubbles in top panel indicate profile views. Colour of country in the bottom panel indicate profile views.

```{r fig4, warning=FALSE, fig.align='center',  fig.height= 8, fig.width=7.65, echo=FALSE}
df_city <- read_excel("geocode_latlon.xlsx")

df_city <- df_city %>%
  mutate(mean_profile_views = as.numeric(mean_profile_views),
         lat = as.numeric(lat),
         lon = as.numeric(lon)) %>% 
  filter(!is.na(lon),
         mean_profile_views > 0,
         lon > -90 & lon < 100,
         lat > 0)

# Filter by countries after data cleaning and transformation
df_city <- df_city %>%
  filter(substr(address, nchar(address) - 1, nchar(address)) %in% eu_countries$code | address == "UK"| address == "CZ" | address == "CH")

world <- map_data("world") %>%
  filter(region %in% eu_countries$name | region == "UK" | region == "Czech Republic" | region == "Switzerland")

# Creating ggplot with map

map_bg <- ggplot(data = world) +
  geom_polygon(aes(x = long, y = lat, group = group), fill = "white", colour = "#000123") +
  coord_map() +
  theme_void()

# Adding scatterplot on the map
views <- map_bg +
  geom_point(data = df_city, aes(x = lon, y = lat, color = mean_profile_views, size = mean_profile_views), alpha = 0.8) +
  scale_colour_gradient(
    name = 'Mean Profile Views',
    limits = range(df_city$mean_profile_views),
    low = "#8c2aef",
    high = "#1beaa7"
  ) +
  scale_size_continuous(guide = "none", range = c(1, 8)) +
  theme(plot.background = element_rect(fill = "#000123", color = "#000123"),
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_blank(),
        legend.key = element_rect(fill = "#000123", color = "#000123"),
        legend.background = element_rect(fill = "#000123"),
        legend.text = element_text(colour = "white"),
        legend.title = element_text(colour = "white", face = "bold"))

print(views)


# Group by country and calculate mean profile views
df_city_grouped <- df_city %>%
  mutate(country_code = substr(address, nchar(address) - 1, nchar(address))) %>%
  group_by(country_code) %>%
  summarise(mean_profile_views = mean(mean_profile_views, na.rm = TRUE))

# Convert two-letter country codes to full country names
df_city_grouped <- left_join(df_city_grouped, eu_countries, by = c("country_code" = "code"))

# Join with the 'world' dataframe
world <- left_join(world, df_city_grouped, by = c("region" = "name")) 
world <- world %>% 
  filter(!is.na(mean_profile_views))

# Create the choropleth map
choropleth <- map_bg + 
  geom_polygon(data = world, aes(x = long, y = lat, fill = mean_profile_views, group = group), color = "#000123") +
  scale_fill_gradient(name = 'Mean Profile Views',
                      low = "#8c2aef",
                      high = "#1beaa7",
                      na.value = "") +
  theme(plot.background = element_rect(fill = "#000123", color = "#000123"),
        legend.key = element_rect(fill = "#000123", color = "#000123"),
        legend.background = element_rect(fill = "#000123"),
        legend.text = element_text(colour = "white"),
        legend.title = element_text(colour = "white", face = "bold"))

print(choropleth)


```

When the data is visualized on a map, one notices that profiles from certain countries tend to get more views. But there's more to the story than geography.

I produced a lollipop chart (figure 5 below) to show the number of users in each region, with the colour of the lollipop indicating mean profile views. What we see is interesting - a country's overall popularity didn't necessarily match up with the number of profile views. This discrepancy can be chalked up to what we call 'sample size bias.' Simply put, countries with less users naturally have a higher total number of views, due to a few very popular individuals pushing up the numbers.

As it turns out that using a profile's country of origin as a way to predict its popularity might be misleading. To make the final model as accurate as possible, it was decided to leave this variable out of the mix.

#### Figure 5: Lollipop chart of number of users by country. The colour of the lollipops indicate mean profile views.

```{r fig5, echo=FALSE, fig.align='center'}

# Count the number of users per country in the 'df' dataframe
df_country_users <- df %>%
  group_by(country) %>%
  summarise(num_users = n())

# Convert two-letter country codes to full country names in df_country_users
df_country_users <- left_join(df_country_users, eu_countries, by = c("country" = "code"))

# Summarise mean_profile_views per country in df_city dataframe
df_city_grouped <- df_city %>%
  mutate(country_code = substr(address, nchar(address) - 1, nchar(address))) %>%
  group_by(country_code) %>%
  summarise(mean_profile_views = mean(mean_profile_views, na.rm = TRUE))

# Join df_city_grouped with df_country_users to add the number of users per country
df_city_grouped <- left_join(df_city_grouped, df_country_users, by = c("country_code" = "country"))

# Create the lollipop chart with number of users and colored by mean profile views
ggplot(df_city_grouped, aes(x = reorder(name, -num_users), y = num_users)) +
  geom_segment(aes(xend = name, yend = 0), color = "white") +
  geom_point(aes(color = mean_profile_views), size = 3, alpha = 0.8) +
  coord_flip() +
  scale_color_gradient(name = 'Mean Profile Views', low = "#8c2aef", high = "#1beaa7") +
  xlab("") +
  ylab("Number of Users") + th +
  theme(legend.position = "right",
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())

```

## Other profile characteristics and popularity

In this sub-section, the objective is to ascertain the impact of various profile attributes on the degree of popularity experienced on the dating application. The attributes under scrutiny regard an array of factors, including the number of pictures a profile has, its verification status, whether it can be shared, and the expressed interests of the profile owner, among others.

In order to illuminate the relationships between these variables and the response - profile likes - a correlogram has been produced, which reveals some notable insights. For instance, a slight negative correlation is observed between profile views and factors such as age, interests leaning towards 'just friends', and shareability of the profile. On the contrary, having a verified status and showcasing multilingual abilities are positively correlated with profile likes, signifying their potential influence in enhancing a profile's appeal.

#### Figure 6: Correlogram of profile characteristics and number of likes received.

```{r fig6, warning=FALSE, fig.align='center',  fig.height= 6.81, fig.width=8, echo=FALSE}

# Calculate the correlation matrix
correlation_matrix <- cor(df[c("counts_kissesStd", "age", "lang_count", "flirtInterests_chat", "flirtInterests_friends", 
                               "flirtInterests_date", "isMobile", "verified", "shareProfileEnabled")])

# Melt the correlation matrix
correlation_matrix_melt <- melt(correlation_matrix)

# Create the ggplot object
ggplot(data = correlation_matrix_melt, aes(x=Var1, y=Var2, fill=value)) +
    geom_tile(color = "white") +
    geom_text(aes(Var1, Var2, label = round(value, 2)), color = "black", size = 4) +
    scale_fill_gradient2(low = "#8c2aef", high = "#1beaa7", mid = "white", 
                         midpoint = 0, limit = c(-1,1), space = "Lab", 
                         name="Correlation") +
    th + 
    theme(
      strip.background = element_blank(),
      strip.text = element_text(face = "bold", size = 14),
      axis.text.x = element_text(angle = 90, vjust = 1, 
                                 size = 12, hjust = 1),
      axis.text.y = element_text(size = 12),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "right") +
    coord_fixed()

```

The significance of language as a determinant of popularity was also explored in this analysis. This was reflected in Figure 6, where the number of languages spoken was considered as a potential predictor of popularity. Subsequently, Figure 7 provides a visualisation of the distribution of received likes in relation to specific languages spoken by the profiles.

Despite these considerations, the investigation does not reveal a discernible difference in the distribution of profile likes contingent on the languages spoken. The absence of any substantial differentiation in this context suggested that the language factor may not hold significant sway over profile popularity. Consequently, the language variable was not included in the formulation of the final predictive models.

#### Figure 7: Ridgeline plot of languages spoken and number of likes received. Dashed line shows overall mean profile likes.

```{r fig7, warning=FALSE, fig.align='center',  fig.height= 8, fig.width=8, echo=FALSE, message=FALSE}

df_long <- df %>%
  pivot_longer(cols = starts_with("lang_"), 
               names_to = "language", 
               values_to = "spoken") %>%
  filter(spoken == TRUE) %>%
  mutate(language = str_remove(language, "lang_"),
         language = recode(language,
                           "de" = "German",
                           "en" = "English",
                           "es" = "Spanish",
                           "fr" = "French",
                           "it" = "Italian",
                           "pt" = "Portuguese"))

df_long %>%
  filter(language != "count", counts_kisses < 1000) %>% 
  ggplot(aes(x = counts_kisses, y = language, fill = language)) +
  geom_density_ridges(scale = 3, rel_min_height = 0.01, colour = "white", alpha = 0.8) +
  scale_fill_manual(values = palette) +
  geom_vline(aes(xintercept = 157.0227), linetype = "dashed", colour = "white") +
  theme_ridges() +
  th +
  theme(legend.position = "none") +
  labs(x = "Profile Kisses Count", y = "Language") +
  annotate("text", x = 170, y = Inf, label = "Mean Kisses Received (~160)", vjust = 2, hjust = 0, size = 4, colour = "white")


```

The perceived attractiveness of a profile is often regarded as a significant determinant of mate searching behaviour. However, the dataset at hand does not include any direct measures of perceived attractiveness. Nevertheless, we have access to a proxy for this attribute, namely the number of pictures present in a profile. While it may not be the most accurate representation of attractiveness, it offers some insight into the visual appeal of a profile.

In conjunction with this, the presence of social media tags on a profile was also examined, given that these tags may serve as additional indicators of social validation or popularity.

Upon examining Figure 8, we observe a correlation between the number of pictures in a profile and the number of profile likes. Specifically, profiles with a lower number of pictures tend to have fewer profile likes, compared to their counterparts with a similar number of pictures but also featuring social media tags. As the number of pictures increases, the distinction between profiles with and without social media tags becomes less apparent.

This implies that while social media tags can enhance the visibility of a profile, their impact diminishes as the number of pictures increases. Thus, the number of pictures in a profile, serving as a rudimentary indicator of attractiveness, can also influence the popularity of a profile to some degree.

#### Figure 8: Dotted line plot of the number of pictures in profile and likes received. The mean number of likes received by number of photos was used to plot this relationship. Lines split based on social media tag presence in profile.

```{r fig8, echo=FALSE, fig.align="center", message=FALSE, warning=FALSE}

df_summary <- df %>%
  group_by(counts_pictures, has_social) %>%
  summarise(mean_kisses = mean(counts_kisses, na.rm = TRUE), 
            .groups = "drop")

df_summary %>%
  filter(counts_pictures < 19 & counts_pictures > 0) %>% 
  ggplot(aes(x = as.factor(counts_pictures), y = mean_kisses, colour = factor(has_social), group = (has_social))) +
  geom_line(size = 1) +
  geom_point() +
  scale_colour_manual(values = c("#1beaa7", "#8c2aef"), 
                    name = "Has Social Media", 
                    labels = c("No Social", "Contains Social")) +
  labs(x = "Pictures Count", 
       y = "Mean Profile Kisses Count", 
       colour = "Contains Social Media") +
  th +
  theme(legend.position = "right")

```

# Part 3: Modelling & Results

After data preparation and exploration, I proceeded with modelling. As a part of the modelling approach for this analysis, I have elected to implement two popular machine learning techniques: decision trees and random forests. These methods were chosen due to their interpretability, effectiveness in handling complex datasets, and their capacity for both classification and regression tasks.

In each of these chosen techniques, two separate models were trained to serve distinct predictive purposes. The first model targets the prediction of profile views, while the second model aims at forecasting profile likes. This dual-model approach was adopted in recognition of the distinct factors that could potentially influence these two different measures of user engagement. Each model is trained on a different set of predictor variables, carefully chosen based on the insights gathered during the data exploration phase.

The first step involves partitioning it into training and testing subsets. I proceed to divide the dataset into training and testing subsets. For this analysis, I have adopted the widely used practice of a 70/30 split, whereby 70% of the data forms the training set and the remaining 30% is reserved for testing. This allocation ensures a balance - ample data to train the model effectively, whilst retaining a substantial portion for assessing the model's performance with unseen data. The code demonstrated below provides the method I employed to execute this data split. Moreover, I undertook this process twice. This resulted in two distinct sets - one set for profile views and another for profile likes, enabling a targeted examination of each aspect of profile engagement.

```{r splitdata_views}

# Set seed for reproducibility
set.seed(777)

# Define training and testing sets for profile visits prediction
split_visits <- initial_split(df, prop = 0.7, strata = "Profile_Views")
training_visits <- training(split_visits)
testing_visits <- testing(split_visits)


```

```{r splitdata_likes}
# Set seed for reproducibility
set.seed(777)

# Define training and testing sets for likes prediction
split_kisses <- initial_split(df, prop = 0.7, strata = "Profile_Likes")
training_kisses <- training(split_kisses)
testing_kisses <- testing(split_kisses)

```

## Decision Tree Model

Decision trees are a type of predictive modeling approach. It is called a decision tree because it brings about a tree-like model of decisions. In this instance, two decision tree models were constructed - one for profile visits and another for profile likes.

For the profile visits model, three predictor variables were considered: 'isOnline' (whether the user is currently online), 'night_owl' (whether the user is active during nighttime hours), and 'age'.

The profile likes model, on the other hand, was slightly more complex, considering a wider array of variables including 'has_emoji', 'has_social', 'Profile_Views', 'counts_pictures', 'lang_count', 'flirtInterests_chat', 'flirtInterests_date', 'flirtInterests_friends', and 'counts_details'. These variables were deemed to be potentially relevant to the number of likes a profile receives.

Once each decision tree model was trained, the 'summary' function was invoked to provide a comprehensive view of the models' characteristics. It includes details such as variable importance, split points, and node summary, providing valuable insights into the models' decision-making process.

```{r decisiontree_create}

# Train decision tree model for profile visits
visits_tree <- rpart(formula = Profile_Views ~ isOnline + night_owl + age,
                     data = training_visits, method = "class")
summary(visits_tree)

# Train decision tree model for profile likes
kisses_tree <- rpart(formula = Profile_Likes ~ has_emoji + has_social + Profile_Views + counts_pictures + lang_count + flirtInterests_chat + flirtInterests_date + flirtInterests_friends + counts_details,
                     data = training_kisses, method = "class")
summary(kisses_tree)


```

The decision tree model for `Profile Views` was trained on a dataset encompassing 2780 observations, using `isOnline`, `night_owl`, and `age` as predictor variables. The variable `isOnline` was deemed the most crucial, contributing significantly to the total reduction of node impurity. `night_owl` and `age` followed in importance. Two key data divisions were created, reflected in the nsplit value, which successfully decreased the relative error. The primary division criteria revolved around `isOnline`, followed by `age` and `night_owl`. Supplementary division rules, termed surrogate splits, were also established.

Conversely, the decision tree model for `Profile Likes` was developed using a wider array of predictor variables: `has_emoji`, `has_social`, `Profile_Views`, `counts_pictures`, `lang_count`, `flirtInterests_chat`, `flirtInterests_date`, `flirtInterests_friends`, and `counts_details`. This model revealed `Profile_Views` as the most significant variable, with `counts_pictures` and `counts_details` next in line. The decision tree model generated four crucial splits, each progressively reducing the relative error. As with the first model, primary and surrogate splits were established, with the former centering around `Profile_Views`.

Each node in these decision tree models divulges key predictive details. To illustrate, Node 2 of the `Profile Views` tree houses 1632 observations. The predicted category here is 'Low', with the anticipated misclassification rate (expected loss) around 0.69. The node also provides a distribution of the target variable categories in terms of probabilities. This step is consistently applied across all nodes and both decision tree models.

The following code chunk applies the model to the test set:

```{r decisiontree_test}

# Predict on testing data
predict_visits <- predict(visits_tree, newdata = testing_visits, type = "class")
predict_kisses <- predict(kisses_tree, newdata = testing_kisses, type = "class")

# Confusion matrices for evaluation
confusionMatrix(predict_visits, testing_visits$Profile_Views)
confusionMatrix(predict_kisses, testing_kisses$Profile_Likes)


```

The output presents the confusion matrices and statistics for the two decision tree models' performance on the testing data.

For the first model, it predicts four categories: Low, Low Mid, High Mid, and High. The model predicted Low for all observations and didn't predict Low Mid and High Mid at all. As a result, the model's accuracy is low at 31.85%, with a 95% confidence interval between 29.21% and 34.58%. The kappa statistic is 0.091, indicating poor agreement between the model's predictions and the actual categories.

For each class, we can observe the following:

1.  Class Low: The model has a sensitivity or true positive rate of 73.91%, meaning it correctly identified 73.91% of the Low class instances. However, its positive predictive value (the proportion of true positives in the predicted positives) is just 31.44%. It indicates a high false positive rate. The model has a balanced accuracy of 60% for this class, which accounts for both sensitivity and specificity and is an overall measure of its performance.

2.  The model didn't predict Low Mid and High Mid at all, which explains the zero values in Sensitivity, Pos Pred Value, and Detection Rate, and NA in Pos Pred Value.

3.  Class High: The model has a sensitivity of 53.36% and a positive predictive value of 32.45%, indicating that the model struggles to accurately identify and predict High class instances. The balanced accuracy is 58.19% for this class.

In the second model, the overall accuracy improves substantially to 71.67%, with a 95% confidence interval between 69.02% and 74.21%. The kappa statistic is 0.6222, indicating a moderate agreement between the model's predictions and the actual categories.

For each class, we can observe the following:

1.  Class Low: The model has a high sensitivity of 82.95% and a positive predictive value of 84.05%. The balanced accuracy is 88.77% for this class, suggesting a good performance in identifying and predicting Low class instances.

2.  Class Low Mid: The model has a moderate sensitivity of 59.52% and a positive predictive value of 62.50%. The balanced accuracy for this class is 73.92%.

3.  Class High Mid: The model's performance decreases for this class, with a sensitivity of 62.84% and a positive predictive value of 58.68%. The balanced accuracy for this class is 74.12%.

4.  Class High: The model performs well with this class, with a sensitivity of 80.87% and a positive predictive value of 81.69%. The balanced accuracy is 87.42% for this class.

The second model outperforms the first one in predicting the test data, with a substantially higher accuracy and moderate agreement between predictions and actual categories. However, there is room for improvement, particularly in predicting the Low Mid and High Mid classes.

Figure 9 below visualises the decision trees.

#### Figure 9: Results of decision tree models.

```{r fig9, echo=FALSE, fig.align='center'}

# Visualize the decision trees
rpart.plot(visits_tree, extra = 1)
rpart.plot(kisses_tree, extra = 1)

```

## Random Forest Model

```{r rfmodel}
# Set seed for reproducibility
set.seed(777)

# Filter out NA values
training_visits <- training_visits %>% filter(!is.na(night_owl))

# Random Forest model for profile visits
visits_rf <- randomForest(formula = Profile_Views ~ isOnline + night_owl + age + genderLooking,
                          data = training_visits,
                          importance = TRUE, 
                          ntree = 500)

# View model summary
visits_rf

# Random Forest model for profile likes
kisses_rf <- randomForest(formula = Profile_Likes ~ has_emoji + has_social + Profile_Views + counts_pictures + lang_count + flirtInterests_chat + flirtInterests_date + flirtInterests_friends + counts_details,
                          data = training_kisses,
                          importance = TRUE, 
                          ntree = 500)

# View model summary
kisses_rf

# Predict on test data
visits_rf_pred <- predict(visits_rf, newdata = testing_visits)
kisses_rf_pred <- predict(kisses_rf, newdata = testing_kisses)

# Confusion matrices
confusionMatrix(visits_rf_pred, testing_visits$Profile_Views)
confusionMatrix(kisses_rf_pred, testing_kisses$Profile_Likes)
```
The outcomes obtained from the two separate random forest models are presented here may be interpreted as follows:

###   Profile Views Random Forest Model

This model aimed to predict 'Profile_Views' utilizing the features: 'isOnline', 'night_owl', 'age', and 'genderLooking'. The training process involved 500 decision trees, with each split in the tree considering 2 variables.

An Out-of-Bag (OOB) error estimate, a commonly used internal measure of the accuracy of random forest models, was computed to be 69.17%. This indicates that the model could not accurately predict the outcomes in about 69.17% of the cases when applied to the out-of-bag sample.

An examination of the confusion matrix reveals varying rates of accuracy across the different classes. For example, the model exhibits the most accurate predictions for the 'Low' category, as evidenced by a class error rate of approximately 36.92%. Conversely, the 'Low Mid' and 'High Mid' categories showed substantial misclassification, reflected by the exceedingly high class error rates close to 98%.

###   Profile Likes Random Forest Model

The second model sought to predict 'Profile_Likes' based on a range of features including 'has_emoji', 'has_social', 'Profile_Views', 'counts_pictures', 'lang_count', 'flirtInterests_chat', 'flirtInterests_date', 'flirtInterests_friends', and 'counts_details'. Similar to the first model, this one was also trained using 500 trees. However, at each split, this model considered 3 variables.

The OOB error rate for the second model is substantially lower at 27.45%, suggesting a better fit to the data as compared to the first model.

Upon analyzing the confusion matrix, it can be observed that the model demonstrated reasonable accuracy for the 'Low' and 'High' classes, with class error rates of 17.44% and 16.71% respectively. Nonetheless, the model encountered challenges with the 'Low Mid' and 'High Mid' categories, where the class error rates were 38.48% and 37.59% respectively.

###   Results from Testing Data

The profile views model demonstrates an overall accuracy rate of 29.28%, indicating that it accurately classifies the data approximately 29.28% of the time. The sensitivity, or true positive rate, varies considerably across classes, with the highest rate (60.74%) observed for the 'Low' category and the lowest rate (1.68%) for the 'Low Mid' category. The specificity, or true negative rate, also varies, ranging from 95.53% for the 'Low Mid' category to 55.26% for the 'Low' category. These variations suggest differential model performance across classes.

The profile likes outcome reveals a more satisfactory accuracy rate of 70.91%. In this case, both sensitivity and specificity are more evenly distributed across the classes, implying more consistent model performance.

In conclusion, the analysis suggests that the second model is more accurate and robust in making predictions compared to the first. It is also important to note that both models show varying performance levels when applied to different classes, which could be due to distinct characteristics within each class that the models capture with varying degrees of success.

Figure 10 below shows the importance of each variable in terms of predictive power for the profile likes random forest model.

#### Figure 10: Importance of variables of random forest model.

```{r fig10, echo=FALSE}
# Extract variable importance data
varImpData <- importance(kisses_rf, type = 1)

# Convert to data frame
varImpDF <- data.frame(
  Importance = varImpData,
  Variable = rownames(varImpData)
)
# Create plot
varImpPlot1 <- ggplot(varImpDF, aes(x = reorder(Variable, -MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) +
  geom_segment(aes(xend = Variable, yend = 0), color = "white") + # Add lollipop 'sticks'
  geom_point(stat = "identity", color = "#1beaa7", size = 3, alpha = 0.7) + # Add lollipop 'heads'
  coord_flip() + # Flip axes
  th + # Add your theme
  labs(title = "Mean Decreases - Accuracy", x = "Variables", y = "Importance")

# Extract variable importance data
varImpData <- importance(kisses_rf, type = 2) # change type to 2 for MeanDecreaseGini

# Convert to data frame
varImpDF <- data.frame(
  Importance = varImpData,
  Variable = rownames(varImpData)
)

# Create plot
varImpPlot2 <- ggplot(varImpDF, aes(x = reorder(Variable, -MeanDecreaseGini), y = MeanDecreaseGini)) +
  geom_segment(aes(xend = Variable, yend = 0), color = "white") +
  geom_point(color = "#8c2aef", size = 3, alpha = 0.7) +
  coord_flip() + # Flip axes
  th +
  labs(title = "Mean Decreases - Gini", x = "Variables", y = "Importance")

```

<div class="row">

::: col-md-6
```{r echo=FALSE}
varImpPlot1
```
:::

::: col-md-6
```{r echo=FALSE}
varImpPlot2
```
:::

# Discussion & Conclusion

The decision tree model demonstrates a level of efficacy; however, it doesn't fully capture the intricate relationships within the data. It relies solely on one predictor, 'profile views,' to formulate its predictions. While 'profile views' may be a critical factor, ignoring other variables potentially diminishes the model's performance.

In comparing the decision tree and random forest models, several key points emerge that offer insights into their relative strengths and weaknesses in this particular application.

###    Model Complexity and Understanding

The decision tree model has the advantage of being relatively simple to understand and interpret. Each decision within the tree corresponds to a question about one of the variables, making it a model that's easy to visualize and explain. However, this simplicity can also be a limitation as it may not capture complex interactions among variables. This may explain its less-than-satisfactory performance on certain metrics, like sensitivity and specificity across various classes, and overall accuracy.

On the other hand, the random forest model, which operates by creating a multitude of decision trees and aggregating their results, is capable of capturing more complex patterns and interactions in the data. However, the trade-off is that it's more challenging to interpret, as it essentially involves a multitude of decision processes rather than just one.

###    Performance

The decision tree model's overall performance was modest at best, especially when compared to the random forest models. Both random forest models demonstrated significantly better performance in terms of overall accuracy and class-specific metrics such as sensitivity and specificity. It is worth noting, however, that even the random forest models had substantial differences in performance, likely due to the different variables included in each model and the number of variables tried at each split.

The decision tree's performance was notably weak when trying to predict certain classes ('Low Mid' and 'High Mid'), indicating that it struggled with differentiating among these classes. This suggests that a single decision tree might not have enough flexibility to capture the nuances of this particular dataset.

###    Robustness

Random forest models are known to be less prone to overfitting compared to decision tree models. This is because they average the results of many different trees, each of which is trained on a slightly different subset of the data. This difference in robustness is likely a contributing factor to the better performance of the random forest models on the test data.

###    Computational Complexity

From a computational perspective, the decision tree model is less resource-intensive, making it a more suitable choice for datasets with a large number of variables or instances. Random forests, however, can require significant computational resources, especially as the number of trees increases.

In conclusion, while the decision tree model might be more easily interpretable and computationally efficient, its performance in this specific scenario was significantly outperformed by the random forest models. This indicates that the random forest, with its ability to capture complex interactions and its robustness to overfitting, was more suited to this dataset. It's a reminder that there's always a trade-off between interpretability and predictive performance, and the best model depends on the specific context and the requirements of the analysis.
