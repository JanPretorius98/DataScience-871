---
title: "Data-Science-871-JHPretorius-Project"
author: "JH Pretorius"
date: "2023-05-24"
output: html_document
css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preface

```{r housekeeping, message=FALSE, warning=FALSE, results=FALSE}
# goal: "Threefold: (1) Transformation and cleaning of data. (2) Exploratory Data Analysis of Dating Site Data. (3) Machine Learning modelling."

# Clear environment
rm(list = ls())
options(scipen = 999)

# Load packages in use
pacman::p_load(dplyr, ggplot2, tidyverse, rsample, caret, glmnet, vip, pdp, stringr, 
               tidytext, emoji, stopwords, ggridges, wordcloud2, ggmap, readxl, maps,
               viridis, eurostat, corrplot, GGally, reshape2, grid, ellipse)

# Define plot themes and palettes
palette <- c("#1beaa7", "#00d9d3", "#C93A86", "#00a5ff", "#007bff", "#8c2aef")

th <- theme(legend.position = "bottom",
            panel.background = element_blank(),
            plot.background = element_rect(fill = "#000123", color = "#000123"),
            panel.grid.major = element_line(color="white", size = 0.1),
            panel.grid.minor = element_line(color="white", size = 0.1),
            axis.title.x=element_text(colour="white", size = 12,
                                      family = "arial", vjust=-2,hjust=0.5, face = "bold"),
            axis.title.y=element_text(colour="white", size = 12,
                                      family = "arial",vjust = 3,hjust=0.5, face = "bold"),
            axis.text.y=element_text(colour ="white", size = 10, 
                                     family = "arial"),
            axis.text.x=element_text(colour="white", size = 10,
                                     family = "arial"),
            plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
            plot.title = element_text(colour="white", size = 16,
                                      family = "arial",hjust=0.5, face = "bold"),
            plot.subtitle = element_text(colour="white", size = 14,
                                         family = "arial"),
            plot.caption = element_text(colour="white", size = 10,
                                        family = "arial"),
            legend.text = element_text(colour="white", size = 12,
                                       family = "arial"),
            legend.title = element_text(colour="white", size = 12,
                                        family = "arial", hjust=3, face = "bold"),
            axis.ticks = element_blank(),
            strip.text = element_text(colour="white", size = 12,
                                      family = "arial", vjust=1,hjust=0.5),
            legend.key = element_rect(fill = "#000123", color = "#000123"),
            legend.background = element_rect(fill = "#000123"))

# Import data
path <- "/Users/janhendrikpretorius/Library/CloudStorage/OneDrive-StellenboschUniversity/Masters-2023/Modules/Data Science/DataScience-871-repo/JHPretorius-Project/Candidate Data Sets/Dating/"
file <- "lovoo_v3_users_api-results.csv"

df <- read_csv(paste0(path, file))

```

# Introduction

The objective of this study is to investigate the critical factors that contribute to an individual's appeal, popularity, and recognition within an online dating platform. The data utilised for this research is sourced from Lovoo, a prominent European dating application, and is accessible via [Kaggle](https://www.kaggle.com/datasets/utkarshx27/lovoo-dating-app-dataset?select=lovoo_v3_users_api-results.csv).

The underlying motivation for this study stems from the desire to comprehend behavioural patterns that transcend the confines of physical attractiveness. The aim is to unveil hidden determinants that may shape interpersonal interactions within a digital dating platform. The behaviour exhibited on these platforms carries significance, even in economic contexts. By deciphering this behavioural paradigm, it can potentially contribute to the development of economic models. These enhanced models can subsequently offer a more profound analytic framework to elucidate overall mate-selection behaviour.

The initial phase of the analysis involves the transformation of raw data into a more interpretable format. This includes the creation of additional variables tailored to augment the predictive capacity of the statistical models employed in subsequent stages. This phase facilitates the exploratory aspect of the research, enabling an in-depth examination of data in search of potential predictor variables. The objective extends beyond understanding the phenomena; the aim is to anticipate which factors instigate an increased number of profile views and, subsequently, the 'likes' received.

The modelling process is a two-step approach. The first stage focuses on identifying variables that may elucidate why individuals view a certain profile. Potential variables include online presence, age, geographical location, and the timing of an individual's online activity. The second stage aims to identify factors that influence the likelihood of a profile receiving 'likes'. These may include the number of pictures on a profile, the characteristics of a profile's biography, languages spoken, profile verification status, and mobile usage.

It is noteworthy that the number of 'likes' received by a profile strongly correlates with the number of views that profile has. Consequently, it may be necessary to use a two-stage model where the first stage models the factors influencing profile views, and the subsequent stage uses the outcomes from the first stage to model the likes received by a profile.

A random forest model is employed in this study due to its robust ability to discern intricate characteristics that influence human behaviour. The model serves as a guide towards achieving a comprehensive understanding of the determinants of attractiveness, popularity, and recognition in the digital dating arena.

# Part 1: Transformation and Cleaning

The data contain around 30 variables, containing information on a particular profile and other demographics. An extract of the data is included below, along with Table 1 that describes some of the relevant variables. The data set only contains data on individuals that identify as female. To this end, I am essentially attempting to understand which factors determine the behaviour of individuals interested in females.

#### Head of dataframe

```{r echo=FALSE}
head(df)
```

#### Table 1: Description of variables in data set.

| Variable               | Description                                                                                                                                 |
|--------------------|----------------------------------------------------|
| `genderLooking`        | Preferred gender the subject is looking to engage with. Represented as 'M' for male, 'F' for female, 'both' for male and female, or 'none'. |
| `age`                  | Age of the individual.                                                                                                                      |
| `counts_details`       | How complete the profile is. Proportion of detail in the account. Measured from 0.0-1.0.                                                    |
| `counts_pictures`      | How many pictures does the profile contain.                                                                                                 |
| `counts_profileVisits` | How many times the profile has been viewed.                                                                                                 |
| `counts_kisses`        | Number of 'kisses' or 'likes' received by profile.                                                                                          |
| `flirtInterests_*`     | What the individual is interested in. '*' represents: 'chat', 'date', 'friends'.                                                             |
| `verified`             | Whether the profile has been verified or not.                                                                                               |
| `lang_count`           | Number of languages spoken by an individual.                                                                                                |
| `lang_*`               | Language spoken by an individual. '*' represents: 'en' (English), 'de' (German), 'fr' (French), 'it' (Italian), 'es' (Spanish).              |
| `whazzup`              | A phrase that represents the profile's 'bio'.                                                                                               |

The raw data is already very useable, but some new variables must be added to produce better models. The first data transformation is to consider the language used by individuals in their profiles. To this end, there are two main operations when discerning the effect of language use on individual behaviour: words used in biographies, and emoji use. Both these factors may reveal characteristics underlying confidence and perceived desirability.

The code chunk below creates two new dummy variables, `has_emoji` and `contains_popular_word`. `has_emoji` attributes a '1' based on whether `wazzup` contains an emoji. `contains_popular_word` attributes a '1' based on whether `wazzup` contains a popular word. The code chunk also outputs which words are the most popular in a word cloud. (The word cloud is a dynamic image that shows the popularity when hovering over a specific word)

```{r words}

# Define stop words for different languages
all_stop_words <- c(stopwords::stopwords("de"), stopwords::stopwords("en"), stopwords::stopwords("fr"))

# Define dummy variable that detects presence of emojis
# Also remove digits from 'whazzup' column
df <- df %>%
  mutate(has_emoji = ifelse(emoji_detect(whazzup), 1, 0),
         whazzup = str_remove_all(whazzup, "[[:digit:]]+"))

# Get the most used words in profile
# First, create a table of words with the corresponding counts_profileVisits
words_visits <- df %>%
  unnest_tokens(word, whazzup) %>%
  select(word, counts_profileVisits)

# Then calculate the mean counts_profileVisits for each word and its count
words <- words_visits %>%
  group_by(word) %>%
  summarise(mean_profileVisits = mean(counts_profileVisits, na.rm = TRUE),
            word_count = n(), 
            .groups = "drop")

# Create word popularity index and determine popular words
words <- words %>%
  mutate(popularity_index = 0.8 * word_count + 0.2 * mean_profileVisits) %>% 
  filter(popularity_index > 200 & word_count > 10, 
         word != "", 
         !is.na(word), 
         !is.na(mean_profileVisits), 
         !is.na(word_count), 
         !is.na(popularity_index)) %>%
  filter(!word %in% all_stop_words)

# Create a single pattern string that matches any word in words$word
words_pattern <- paste(words$word, collapse = "|")

# Add the new variable to df
df <- df %>%
  mutate(contains_popular_word = ifelse(str_detect(whazzup, words_pattern), 1, 0)) %>%
  mutate(
    contains_popular_word = replace_na(contains_popular_word, 0),
    has_emoji = replace_na(has_emoji, 0)
  )

words <- words %>%
  arrange(desc(popularity_index)) %>% 
  select(c(word, popularity_index))

```
####    Figure 1: Word cloud of popular words in bios.
```{r echo=FALSE, fig.align="center"}
# Create Word Cloud
wordcloud2(words, size=1.6, color='random-light', backgroundColor = "#000123")
```

Interestingly, one may see that popular words (those are words that get many profile views and are used frequently), are social media tags. That is, individuals that have their social media details, such as their Instagram handle, Facebook name, and Snapchat handle, tend to get more profile views. As such, I will create another variable, called `has_social` that captures whether a profile contains social media particulars. Due to endogeneity and possible multicollinearity between `contains_popular_word` and `has_social`, only one can be used in modelling. Whichever delivers the most accurate result will then be used.

```{r warning=FALSE}

social <- "instagram|insta|facebook|fb|snapchat|snap"
df <- df %>%
  mutate(whazzup = tolower(whazzup),
         has_social = as.numeric(str_detect(whazzup, social))) %>%
  replace_na(list(has_social = 0))

```


Another operation pertains to the time an individual is online. I add a new dummy variable called `night_owl` to the dataframe based on whether a person was online at night or not. The motivation behind this is that dating apps tend to be more popular in the evenings, than during daytime.

```{r, warning=FALSE}
df <- df %>%
  mutate(night_owl = ifelse(hour(hms(substr(lastOnlineDate, 12, 19))) > 18 | 
                            hour(hms(substr(lastOnlineDate, 12, 19))) < 6, 1, 0))

```

Finally, before kicking off with the exploratory data analysis, it might be fitting to standardise the following three variables: `counts_profileVisits`, `counts_kisses`, and `counts_pictures`. This operation may help to more clearly visualise how some variables influence each other.

```{r}

df$counts_profileVisitsStd <- scale(df$counts_profileVisits)
df$counts_kissesStd <- scale(df$counts_kisses)
df$counts_picturesStd <- scale(df$counts_pictures)


```


# Part 2: Exploratory Data Analysis

This section concerns finding relationships in the data. I initiate with a graphical analysis of the different variables to determine their relevance. Thereafter, I made use of a stepwise regression to determine which variables produce the best fitting model. However, it is important to not disregard some variables because they did not pass the 'stepwise' test. As such the final model will be advised by the results of the stepwise regression, but not absolutely decided by it.

As briefly mentioned in the introduction, some variables influence number of likes, whereas others influence profile views. The motivation behind this distinction refers to the fact that it does not make sense that some profile characteristics that are observed are only seen once a profile is being viewed. A profile biography, for example. There is, however, a strong correlation between profile views and profile likes. Figure 2 below visualises this relationship.

#### Figure 2: Bubble plot of profile views and number of pictures in profile. A non-linear model (loess method) was fitted on the plot to discern possible patterns and differences between bios with emojis and those without. Size of dots present how detailed the account is.
```{r echo=FALSE, fig.align="center", message=FALSE}
df %>%
  filter(counts_profileVisits < 100000) %>% 
  ggplot(aes(x = counts_profileVisits, y = counts_kisses)) +
  geom_point(aes(fill = factor(has_emoji), size = counts_details), pch = 21, alpha = 0.8, colour = "white") +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji")) +
  scale_size(range = c(0.1, 4)) +
  labs(x = "Profile Visits Count", y = "Number of Kisses", size = "Details Count", fill = "Contains Emoji") +
  th + theme(legend.position = "right") +
  geom_smooth(aes(colour = factor(has_emoji)), method = "loess", se = FALSE) +
  scale_colour_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji"))

```

##    Biography characteristics and popularity

Figure 3 below seeks to present whether there is a difference in the distribution of likes received based on the newly created dummy variables, `has_emoji`, `contains_popular_word`, and `night_owl`. There seem to be some slight differences in likes received, supporting the idea that the use of emojis and certain words do suggest higher levels of trust. Being online during night time also may increase profile views, but I view this variable more as a control variable, rather than a causal one, as more people tend to be online during night time than in day time.

#### Figure 3: Boxplots showing effects of profile characteristics on popularity. Left panel: effect of a bio containing social media particulars and/or an emoji on likes received. Right panel: effect of an online profile and/or being a night owl on number of profile visits.

```{r, echo=FALSE, fig.align="center", fig.height= 10, fig.width=7, warning=FALSE}
plot1 <- df %>%
  filter(counts_kissesStd < 2, !is.na(night_owl), !is.na(has_social)) %>%
  mutate(has_emoji = factor(has_emoji, labels = c("No", "Yes")),
         night_owl = factor(night_owl, labels = c("No", "Yes")),
         has_social = factor(has_social, labels = c("No", "Yes"))) %>%
  pivot_longer(cols = c(has_emoji, has_social), names_to = "Factor", values_to = "Value") %>%
  mutate(Factor = recode(Factor, 
                         has_emoji = "Emoji",
                         has_social = "Social Media")) %>%
  ggplot(aes(x = Value, y = counts_kissesStd, fill = Value)) +
  geom_boxplot(colour = "white", alpha = 0.8) +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef")) +
  facet_wrap(~ Factor, scales = "free", strip.position = "top") +
  labs(x = "", y = "Profile Kisses Count", fill = "") +
  th +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 14),
    axis.text.x = element_blank()
  ) +
  scale_y_continuous(breaks = c(-1, 0, 1, 2))

plot2 <- df %>%
  filter(counts_profileVisitsStd < 2, !is.na(night_owl), !is.na(isOnline)) %>%
  mutate(night_owl = factor(night_owl, labels = c("No", "Yes")),
         isOnline = factor(isOnline, labels = c("No", "Yes"))) %>%
  pivot_longer(cols = c(night_owl, isOnline), names_to = "Factor", values_to = "Value") %>%
  mutate(Factor = recode(Factor,
                         night_owl = "Night Owl",
                         isOnline = "Online")) %>%
  ggplot(aes(x = Value, y = counts_profileVisitsStd, fill = Value)) +
  geom_boxplot(colour = "white", alpha = 0.8) +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef")) +
  facet_wrap(~ Factor, scales = "free", strip.position = "top") +
  labs(x = "", y = "Profile Visits Count", fill = "") +
  th +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(face = "bold", size = 14),
    axis.text.x = element_blank()
  ) +
  scale_y_continuous(breaks = c(-1, 0, 1, 2))
```
<div class="row">
<div class="col-md-6">
```{r echo=FALSE}
plot1
```
</div>
<div class="col-md-6">
```{r echo=FALSE}
plot2
```
</div>

##    Geographical characteristics and popularity

By using the Google Maps API, I was able to geocode the locations of every profile in the data. The goal is to visualise how location effects profile views. The code chunk below was used to geocode the data.
```{r}
# Note: commented out, due to costs associated with geocoding through the API
# df_city <- df %>% 
#   select(c(city, country, counts_profileVisits)) %>% 
#   mutate(address = paste0(city, ", ", country)) %>%
#   group_by(address) %>%
#   summarise(mean_profile_views = mean(counts_profileVisits, na.rm = TRUE))
# 
# df_city <- df_city %>%
#   mutate(geocode_data = map(address, ~geocode(.x, source = "google", output = "latlon")),
#          lon = map_dbl(geocode_data, "lon"),
#          lat = map_dbl(geocode_data, "lat"))
# 
# write_csv(df_city, "geocode_latlon.csv")

```
####    Figure 4: Geographic data visualisation of profile views. Size and colour of bubbles in top panel indicate profile views. Colour of country in the bottom panel indicate profile views.
```{r warning=FALSE, fig.align='center',  fig.height= 8, fig.width=7.65, echo=FALSE}
df_city <- read_excel("geocode_latlon.xlsx")

df_city <- df_city %>%
  mutate(mean_profile_views = as.numeric(mean_profile_views),
         lat = as.numeric(lat),
         lon = as.numeric(lon)) %>% 
  filter(!is.na(lon),
         mean_profile_views > 0,
         lon > -90 & lon < 100,
         lat > 0)

# Filter by countries after data cleaning and transformation
df_city <- df_city %>%
  filter(substr(address, nchar(address) - 1, nchar(address)) %in% eu_countries$code | address == "UK"| address == "CZ" | address == "CH")

world <- map_data("world") %>%
  filter(region %in% eu_countries$name | region == "UK" | region == "Czech Republic" | region == "Switzerland")

# Creating ggplot with map

map_bg <- ggplot(data = world) +
  geom_polygon(aes(x = long, y = lat, group = group), fill = "white", colour = "#000123") +
  coord_map() +
  theme_void()

# Adding scatterplot on the map
views <- map_bg +
  geom_point(data = df_city, aes(x = lon, y = lat, color = mean_profile_views, size = mean_profile_views), alpha = 0.8) +
  scale_colour_gradient(
    name = 'Mean Profile Views',
    limits = range(df_city$mean_profile_views),
    low = "#8c2aef",
    high = "#1beaa7"
  ) +
  scale_size_continuous(guide = "none", range = c(1, 8)) +
  theme(plot.background = element_rect(fill = "#000123", color = "#000123"),
        panel.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_blank(),
        legend.key = element_rect(fill = "#000123", color = "#000123"),
        legend.background = element_rect(fill = "#000123"),
        legend.text = element_text(colour = "white"),
        legend.title = element_text(colour = "white", face = "bold"))

print(views)


# Group by country and calculate mean profile views
df_city_grouped <- df_city %>%
  mutate(country_code = substr(address, nchar(address) - 1, nchar(address))) %>%
  group_by(country_code) %>%
  summarise(mean_profile_views = mean(mean_profile_views, na.rm = TRUE))

# Convert two-letter country codes to full country names
df_city_grouped <- left_join(df_city_grouped, eu_countries, by = c("country_code" = "code"))

# Join with the 'world' dataframe
world <- left_join(world, df_city_grouped, by = c("region" = "name")) 
world <- world %>% 
  filter(!is.na(mean_profile_views))

# Create the choropleth map
choropleth <- map_bg + 
  geom_polygon(data = world, aes(x = long, y = lat, fill = mean_profile_views, group = group), color = "#000123") +
  scale_fill_gradient(name = 'Mean Profile Views',
                      low = "#8c2aef",
                      high = "#1beaa7",
                      na.value = "") +
  theme(plot.background = element_rect(fill = "#000123", color = "#000123"),
        legend.key = element_rect(fill = "#000123", color = "#000123"),
        legend.background = element_rect(fill = "#000123"),
        legend.text = element_text(colour = "white"),
        legend.title = element_text(colour = "white", face = "bold"))

print(choropleth)


```
Geographically presenting the data shows that profiles from some countries do indeed tend to receive more attention. It is necessary, however, to understand whether there is a different factor carrying mean profile views for different countries. Below I have created lollipop charts that show number of users for each specific region. From figure 4 below, it is clear that the country an individual comes from may not be a good indicator of fame in the data to my disposal. This is because of sample size bias. As such, it is advised to omit this variable from the final model.

####    Figure 5: Lollipop chart of number of users by country. The colour of the lollipops indicate mean profile views.

```{r echo=FALSE, fig.align='center'}

# Count the number of users per country in the 'df' dataframe
df_country_users <- df %>%
  group_by(country) %>%
  summarise(num_users = n())

# Convert two-letter country codes to full country names in df_country_users
df_country_users <- left_join(df_country_users, eu_countries, by = c("country" = "code"))

# Summarise mean_profile_views per country in df_city dataframe
df_city_grouped <- df_city %>%
  mutate(country_code = substr(address, nchar(address) - 1, nchar(address))) %>%
  group_by(country_code) %>%
  summarise(mean_profile_views = mean(mean_profile_views, na.rm = TRUE))

# Join df_city_grouped with df_country_users to add the number of users per country
df_city_grouped <- left_join(df_city_grouped, df_country_users, by = c("country_code" = "country"))

# Create the lollipop chart with number of users and colored by mean profile views
ggplot(df_city_grouped, aes(x = reorder(name, -num_users), y = num_users)) +
  geom_segment(aes(xend = name, yend = 0), color = "white") +
  geom_point(aes(color = mean_profile_views), size = 3, alpha = 0.6) +
  coord_flip() +
  scale_color_gradient(name = 'Mean Profile Views', low = "#8c2aef", high = "#1beaa7") +
  xlab("") +
  ylab("Number of Users") + th +
  theme(legend.position = "right",
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())

```

##    Profile characteristics and popularity

The goal of this section is to understand whether certain details on a profile affect popularity on a dating app.

####    Figure 6: Correlogram of profile characteristics and number of likes received.
```{r warning=FALSE, fig.align='center',  fig.height= 6.81, fig.width=8, echo=FALSE}

# Calculate the correlation matrix
correlation_matrix <- cor(df[c("counts_kissesStd", "age","flirtInterests_chat", "flirtInterests_friends", 
                               "flirtInterests_date", "isMobile", "verified", "shareProfileEnabled")])

# Melt the correlation matrix
correlation_matrix_melt <- melt(correlation_matrix)

# Create the ggplot object
ggplot(data = correlation_matrix_melt, aes(x=Var1, y=Var2, fill=value)) +
    geom_tile(color = "white") +
    geom_text(aes(Var1, Var2, label = round(value, 2)), color = "black", size = 4) +
    scale_fill_gradient2(low = "#1beaa7", high = "#8c2aef", mid = "white", 
                         midpoint = 0, limit = c(-1,1), space = "Lab", 
                         name="Correlation") +
    th + 
    theme(
      strip.background = element_blank(),
      strip.text = element_text(face = "bold", size = 14),
      axis.text.x = element_text(angle = 90, vjust = 1, 
                                 size = 12, hjust = 1),
      axis.text.y = element_text(size = 12),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      legend.position = "right") +
    coord_fixed()

```


#### Figure 7: Bubble plot of number of pictures in profile and likes received. A non-linear model (loess method) was once again fitted on the plot to discern possible patterns and differences between bios with emojis and those without. Size of dots present how detailed the account is.

```{r echo=FALSE, fig.align="center", message=FALSE}

df %>%
  ggplot(aes(y = counts_kissesStd, x = counts_picturesStd)) +
  geom_point(aes(fill = factor(has_emoji), size = counts_details), pch = 21, alpha = 0.8, colour = "white") +
  scale_fill_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji")) +
  scale_size(range = c(0.2, 3)) +
  labs(y = "Profile Visits Count", x = "Pictures Count", size = "Details Count", fill = "Contains Emoji") +
  th + theme(legend.position = "right") +
  geom_smooth(aes(colour = factor(has_emoji)), method = "loess", se = FALSE) +
  scale_colour_manual(values = c("#1beaa7", "#8c2aef"), name = "Has Emoji", labels = c("No Emoji", "Contains Emoji"))
```


```{r}


```



# Part 3: Modelling & Results

# Discussion & Conclusion

